{
  "name": "pattern-match",
  "description": "A pattern-matching DSL for JSON-like trees of data.",
  "main": "lib/match.js",
  "version": "0.3.0",
  "engines": {
    "node": ">=0.8.6"
  },
  "author": {
    "name": "Dave Herman"
  },
  "license": "MIT",
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "0.7.4"
  },
  "directories": {
    "lib": "./lib"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dherman/pattern-match.git"
  },
  "keywords": [
    "match",
    "pattern matching",
    "pattern"
  ],
  "readme": "## pattern-match\n\nA pattern matching DSL for JavaScript. The module is a function that\ntakes an arbitrary JavaScript value and tests it against a\n*pattern*. If the match succeeds, the result is a *sub-match object*,\nwhich consists of the sub-components of the value that matched named\nsub-patterns (using the `var` pattern). If the match fails, a\n`MatchError` is thrown.\n\n## Usage\n\nHere's a simple example of using pattern matching to analyze an AST\nfor a hypothetical language:\n\n```javascript\nvar match = require('pattern-match');\n\nmatch(ast, function(when) {\n    when({\n        type: 'FunctionCall',\n        callee: match.var('callee'),\n        args: match.var('args')\n    }, function(vars) {\n        this.analyzeFunctionCall(vars.callee, vars.args);\n    }, this);\n\n    when({\n        type: 'Assignment',\n        lhs: match.var('lhs'),\n        rhs: match.var('rhs')\n    }, function(vars) {\n        this.analyzeAssignment(vars.lhs, vars.rhs);\n    }, this);\n\n    when({\n        type: 'Return',\n        arg: match.var('arg')\n    }, function(vars) {\n        this.analyzeReturn(vars.arg);\n    }, this);\n}, this);\n```\n\nThis will get sweeter in ES6 with destructuring:\n\n```javascript\nvar match = require('pattern-match');\n\nmatch(ast, function(when) {\n    when({\n        type: 'FunctionCall',\n        callee: match.var('callee'),\n        args: match.var('args')\n    }, function({ callee, args }) {\n        this.analyzeFunctionCall(callee, args);\n    }, this);\n\n    when({\n        type: 'Assignment',\n        lhs: match.var('lhs'),\n        rhs: match.var('rhs')\n    }, function({ lhs, rhs }) {\n        this.analyzeAssignment(lhs, rhs);\n    }, this);\n\n    when({\n        type: 'Return',\n        arg: match.var('arg')\n    }, function({ arg }) {\n        this.analyzeReturn(arg);\n    }, this);\n}, this);\n```\n\nAnd sweeter still with ES6 arrow-functions:\n\n```javascript\nvar match = require('pattern-match');\n\nmatch(ast, (when) => {\n    when({\n        type: 'FunctionCall',\n        callee: match.var('callee'),\n        args: match.var('args')\n    }, ({ callee, args }) => {\n        this.analyzeFunctionCall(callee, args);\n    });\n\n    when({\n        type: 'Assignment',\n        lhs: match.var('lhs'),\n        rhs: match.var('rhs')\n    }, ({ lhs, rhs }) => {\n        this.analyzeAssignment(lhs, rhs);\n    });\n\n    when({\n        type: 'Return',\n        arg: match.var('arg')\n    }, ({ arg }) => {\n        this.analyzeReturn(arg);\n    });\n});\n```\n\n\n## API\n\n### Entry points\n\n  * **match(x, body[, thisArg])**\n\nMatch `x` against a sequence of patterns, returning the result of the\nfirst successful match. The cases are provided by the `body` function:\n\n  * **body.call(thisArg, when)**\n\nProvides the cases by calling `when` in the order the cases should be\ntried. The library calls `body` with the `thisArg` provided to `match`\nas the binding of `this`.\n\n  * **when(pattern[, template[, thisArg]])**\n\nProvides the next case, consisting of a pattern an optional\ntemplate. If matching the pattern succeeds, the result is passed to\n`template` with `thisArg` bound to `this` (defaults to the global\nobject). If `template` is not provided, this case produces the\nsub-match object.\n\n  * **match(x).when(pattern[, template[, thisArg]])**\n\nMatch `x` against a single pattern. Returns the result of calling\n`template` on the sub-match object with `thisArg` (or the global\nobject by default) as the binding of `this`. If `template` is not\nprovided, returns the sub-match object.\n\n\n### Patterns\n\n  * **match.any** - matches any value.\n  * **match.primitive** - matches any primitive (non-object) value.\n  * **match.object** - matches any non-null object.\n  * **match.array** - matches anything `Array.isArray` matches.\n  * **match.function** - assumes the pattern is a boolean-valued function and matches any value for which the function returns true.\n  * **match.null** - matches the `null` value.\n  * **match.undefined** - matches the `undefined` value.\n  * **match.boolean** - matches any boolean value.\n  * **match.number** - matches any number value.\n  * **match.int32** - matches any integral number value in the range [-2^31, 2^31).\n  * **match.uint32** - matches any integral number value in the range [0, 2^32).\n  * **match.integer** - matches any integral number value, including -Infinity and Infinity.\n  * **match.finite** - matches any number value other than NaN, -Infinity, and Infinity.\n  * **match.infinite** - matches -Infinity and Infinity.\n  * **match.negative** - matches any number less than 0.\n  * **match.positive** - matches any number greater than 0.\n  * **match.nonnegative** - matches any number greater than or equal to 0 (including -0, which most of the time should just be considered 0).\n  * **match.plusZero** - matches only +0 (and not -0). *If you don't know if you need this, don't use it.*\n  * **match.minusZero** - matches only -0 (and not +0). *If you don't know if you need this, don't use it.*\n  * **match.range(low, high)** - matches any number value in the half-open range [`low`, `high`).\n  * **match.string** - matches any string value.\n  * **match.var(name[, pattern])** - matches the `pattern` (defaults to `any`) and saves the value in the sub-match object with property name `name`.\n  * **match.all(pattern, ...)** - matches if every `pattern` matches.\n  * **match.some(pattern, ...)** - matches if one `pattern` matches.\n  * **pred(testValue)** - matches any value for which `pred` returns a truthy value.\n  * **{ x1: pattern1, ..., xn: patternn }** - matches any object with property names `x1` to `xn` matching patterns `pattern1` to `patternn`, respectively. Only the own properties of the pattern are used.\n  * **[ pattern0, ..., patternn ]** - matches any object with property names 0 to n matching patterns `pattern0` to `patternn`, respectively.\n\n### Custom patterns\n\nYou can create custom patterns by extending the root pattern prototype.\n\n  * **match.pattern** - the root pattern prototype.\n\n### Match errors\n\n  * **match.MatchError** - an object extending `Error` that represents a failed pattern-match.\n      * **e.expected** - the expected pattern.\n      * **e.actual** - the actual value tested.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/dherman/pattern-match/issues"
  },
  "_id": "pattern-match@0.3.0",
  "_from": "pattern-match@"
}
